# printf 与测试工程

## printf 大法
> printf 大法不专指 `printf`，在 C 中也可以是 `puts` 等输出函数，又或许是 C++ 的 `cout`、Python 的 `print`、Java 的 `System.out.println`，甚至是打日志

printf 大法的强大之处在于它可以在程序的各种位置灵活输出你所关心的变量值，各路大神通过 printf 侧面剖析程序的运行情况，堪称管中窥豹以见症结的神技。在业界应用中，printf 大法甚至可以让上线的代码继续维持运行，只是在关键节点打印信息以检查错误，减少服务下线带来的损失。

在这里介绍一下我本人应用 printf 的框架：

- 定位问题发生的区域
- 定位异常变量
- 定位问题发生的代码

例如程序陷入了死循环，那么可以

- 定位问题发生的区域：各个循环前后设置 printf，根据输出初步判断在哪个循环发生了死循环
- 定位异常变量：关注这个死循环，打印你所关心的几个变量，看看哪个变量和预期结果不符
- 定位问题发生的代码：静态思考，或者在循环内部代码级设置 printf，定位哪一句发生了问题
- 如果一句代码中做了很多事，那么可以拆分这句代码进行更细粒度的分析

因此建议不要压行，一句代码不必做太多事情，否则不仅阅读有困难，调试也会比较麻烦。

## 软件工程测试理论

在软件工程中，大部分的软件都可以采用以下两种方式之一进行测试：

- 黑盒测试：采用外部视角，关注软件的功能而不是内部结构
- 白盒测试：采用内部视角，基于过程细节进行封闭检查

> 乍一看，好像是全面的白盒测试将获得“100% 正确的程序”。我们需要做的只是识别所有的逻辑路径，开发相应的测试用例、执行测试用例并评估结果，彻底地测试程序逻辑。遗憾的是，穷举测试存在某种逻辑问题，即使对于小程序，可能的逻辑路径的数量也可能非常大。然而，不应该觉得白盒测试不切实际而抛弃这种方法。可以选择并测试有限数量的重要逻辑路径，检测重要数据结构的有效性。——选自《软件工程：实践者的研究方法》第八版

### 黑盒测试：等价类划分与边界值分析

例如一个简单的程序：低于 175cm 的同学统一分配 XL 的衣服，高于 180cm 的同学分配 3XL 的衣服，其他同学分配 2XL 的衣服，那么可以划分以下三个等价类

$$
(0, 175), \quad [175, 180], \quad  (180, +\infty)
$$

在程序预期任务上，各自范围内的数值输入应当有相同的输出结果，这就是等价类划分的方法。

边界值分析，顾名思义，要对 175 和 180 这两个数据进行单独测试。除此之外，如果身高允许是浮点数，那么一个人想要使坏可能故意报自己的身高是 174.9999999...cm，那么程序还是可能会出现错误，因此严格的软件工程测试中还需要测试很接近 175 和很接近 180 的值。

需要注意的是，理论题可能会问你最少需要几个样例的测试，一般认为这种情况需要 5 个，即测试三个范围的普通值，以及两个边界值。

### 白盒测试

白盒测试的理论以分析基本路径与控制结构居多，在此用处不大，便不赘述了。

重点关注一个现象，程序中往往存在一些很少被实际执行的分支，这些分支往往是 bug 潜藏的重灾区，因为频繁执行的分支一般能快速暴露出 bug 所在。因此需要善于观察程序的死角，另外黑盒测试中一些巧妙设计的测试样例也能够发现一些缺乏考虑的代码死角。